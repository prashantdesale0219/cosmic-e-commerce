// Backend Models for Product Details Page
// Assuming Node.js with Express and Mongoose (MongoDB) for the backend.
// These schemas cover all data points used in the ProductDetails component.
// I've designed them to be normalized where possible (e.g., separate Review and Offer models)
// to avoid redundancy and enable efficient querying.
// Relationships:
// - Product hasMany Images (embedded or separate collection)
// - Product hasMany Features (embedded)
// - Product hasMany Specifications (embedded as key-value)
// - Product belongsToMany Applications (separate model for reusability across products)
// - Product hasMany RelatedProducts (via query, not embedded to avoid duplication)
// - Product hasMany RecommendedProducts (via query)
// - Product hasMany Reviews (separate model)
// - Product hasMany Offers (separate model, reusable)
// - Average rating calculated from Reviews on fetch.

// File: models/Product.js
const mongoose = require('mongoose');

const productSchema = new mongoose.Schema({
  id: { type: String, required: true, unique: true }, // Custom ID like 'SP-10W'
  name: { type: String, required: true }, // e.g., 'Solar Panel 10W 12V Monocrystalline'
  price: { type: Number, required: true, min: 0 }, // Original price, e.g., 1299.00
  discountPrice: { type: Number, required: true, min: 0 }, // Discounted price, e.g., 999.00
  stock: { type: Number, required: true, min: 0, default: 0 }, // Available stock, e.g., 50
  rating: { type: Number, min: 0, max: 5, default: 0 }, // Average rating (computed from reviews)
  reviewCount: { type: Number, default: 0 }, // Total reviews, e.g., 245
  description: { type: String, required: true }, // Product description
  features: [{
    type: { type: String, required: true }, // e.g., 'High conversion efficiency'
    value: { type: String, required: true } // e.g., '21%'
  }], // Array of feature objects, e.g., [{ type: 'High conversion efficiency', value: '21%' }]
  specifications: { 
    type: mongoose.Schema.Types.Mixed, // Key-value object, e.g., { 'Maximum Power': '10W', 'Cell Type': 'Monocrystalline' }
    default: {}
  },
  applications: [{ type: mongoose.Schema.Types.ObjectId, ref: 'Application' }], // References to Application model
  isBestseller: { type: Boolean, default: false }, // For the bestseller badge
  images: [{ type: mongoose.Schema.Types.ObjectId, ref: 'Image' }], // References to Image model (main and thumbnails)
  category: { type: mongoose.Schema.Types.ObjectId, ref: 'Category' }, // For querying related/recommended products
  createdAt: { type: Date, default: Date.now },
  updatedAt: { type: Date, default: Date.now }
});

productSchema.pre('save', function(next) {
  this.updatedAt = Date.now();
  next();
});

// Virtual for computed fields (e.g., discount percentage)
productSchema.virtual('discountPercentage').get(function() {
  return Math.round(((this.price - this.discountPrice) / this.price) * 100);
});

// Index for efficient queries
productSchema.index({ category: 1, isBestseller: 1 });
productSchema.index({ id: 1 });

module.exports = mongoose.model('Product', productSchema);

// File: models/Image.js
// Separate model for images to allow easy management and CDN integration
const imageSchema = new mongoose.Schema({
  url: { type: String, required: true }, // e.g., '/images/solar-panel-main.jpg'
  alt: { type: String, required: true }, // e.g., 'Solar Panel 10W 12V Monocrystalline'
  isMain: { type: Boolean, default: false }, // Flag for main image
  product: { type: mongoose.Schema.Types.ObjectId, ref: 'Product', required: true },
  createdAt: { type: Date, default: Date.now }
});

module.exports = mongoose.model('Image', imageSchema);

// File: models/Application.js
// Reusable across products for applications like 'Solar System', 'Home', etc.
const applicationSchema = new mongoose.Schema({
  name: { type: String, required: true }, // e.g., 'Solar System'
  icon: { type: String, required: true }, // Icon name, e.g., 'FaSolarPanel' (render on frontend)
  description: { type: String }, // Optional short description
  category: { type: mongoose.Schema.Types.ObjectId, ref: 'Category' } // Optional link to category
});

// Index
applicationSchema.index({ name: 1 });

module.exports = mongoose.model('Application', applicationSchema);

// File: models/Review.js
// Separate model for reviews to compute average rating dynamically
const reviewSchema = new mongoose.Schema({
  product: { type: mongoose.Schema.Types.ObjectId, ref: 'Product', required: true },
  user: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true }, // Assuming User model exists
  rating: { type: Number, required: true, min: 1, max: 5 }, // 1-5 stars
  comment: { type: String, required: true }, // Review text
  title: { type: String }, // Optional review title
  images: [{ type: String }], // Optional user-uploaded images
  isVerified: { type: Boolean, default: false }, // Verified purchase
  createdAt: { type: Date, default: Date.now },
  updatedAt: { type: Date, default: Date.now }
});

reviewSchema.pre('save', function(next) {
  this.updatedAt = Date.now();
  next();
});

// Static method to compute average rating for a product
reviewSchema.statics.computeAverageRating = async function(productId) {
  const reviews = await this.find({ product: productId });
  const avgRating = reviews.reduce((sum, review) => sum + review.rating, 0) / reviews.length || 0;
  const reviewCount = reviews.length;
  
  // Update product's rating and reviewCount
  await mongoose.model('Product').findByIdAndUpdate(productId, {
    rating: parseFloat(avgRating.toFixed(1)),
    reviewCount: reviewCount
  });
  
  return { avgRating, reviewCount };
};

// Index
reviewSchema.index({ product: 1, createdAt: -1 }); // For fetching recent reviews

module.exports = mongoose.model('Review', reviewSchema);

// File: models/Offer.js
// Reusable for EMI and Brand offers, applicable to products or globally
const offerSchema = new mongoose.Schema({
  title: { type: String, required: true }, // e.g., 'EMI3MONTHS'
  type: { type: String, enum: ['emi', 'brand'], required: true }, // 'emi' or 'brand'
  discount: { type: String, required: true }, // e.g., '0%', '5%', 'â‚¹500'
  description: { type: String, required: true }, // e.g., 'No interest EMI for 3 months'
  details: { type: String, required: true }, // Full details for modal
  couponCode: { type: String }, // Optional coupon code
  minPurchaseValue: { type: Number, min: 0 }, // e.g., 3000
  maxDiscount: { type: Number, min: 0 }, // e.g., 1000 for cashback
  validFrom: { type: Date },
  validTo: { type: Date },
  applicableProducts: [{ type: mongoose.Schema.Types.ObjectId, ref: 'Product' }], // Or global if empty
  isActive: { type: Boolean, default: true }
});

// Static method to get offers for a product (EMI and Brand tabs)
offerSchema.statics.getOffersForProduct = async function(productId, type) {
  return await this.find({
    $or: [{ applicableProducts: productId }, { applicableProducts: { $exists: false } }], // Global or product-specific
    type: type,
    isActive: true,
    validTo: { $gte: new Date() } // Valid offers only
  }).sort({ createdAt: -1 });
};

// Index
offerSchema.index({ type: 1, isActive: 1, validTo: 1 });

module.exports = mongoose.model('Offer', offerSchema);

// File: models/Category.js
// For grouping related and recommended products (assuming exists for querying)
const categorySchema = new mongoose.Schema({
  name: { type: String, required: true }, // e.g., 'Solar Panels'
  slug: { type: String, required: true, unique: true },
  description: { type: String },
  parent: { type: mongoose.Schema.Types.ObjectId, ref: 'Category' } // For sub-categories
});

module.exports = mongoose.model('Category', categorySchema);

// Usage Example in Controller (e.g., productController.js)
// To fetch full product details for the component:
exports.getProductDetails = async (req, res) => {
  try {
    const productId = req.params.id; // e.g., 'SP-10W'
    
    // Fetch product
    const product = await Product.findOne({ id: productId }).populate('images applications');
    
    if (!product) return res.status(404).json({ error: 'Product not found' });
    
    // Fetch reviews and compute rating if needed
    await Review.computeAverageRating(product._id);
    const reviews = await Review.find({ product: product._id })
      .sort({ createdAt: -1 })
      .limit(10) // For display in reviews tab
      .populate('user', 'name'); // Assuming User has name field
    
    // Fetch offers
    const emiOffers = await Offer.getOffersForProduct(product._id, 'emi');
    const brandOffers = await Offer.getOffersForProduct(product._id, 'brand');
    
    // Fetch related products (same category, exclude self)
    const relatedProducts = await Product.find({
      category: product.category,
      _id: { $ne: product._id }
    }).limit(3).populate('images');
    
    // Fetch recommended (e.g., based on category or manual curation)
    const recommendedProducts = await Product.find({
      category: product.category // Or a 'recommendedFor' field in Product
    }).limit(4).populate('images');
    
    // Populate applications with icons (icons are strings, render on FE)
    const applications = await Application.find({ _id: { $in: product.applications } });
    
    res.json({
      product,
      reviews,
      emiOffers,
      brandOffers,
      relatedProducts,
      recommendedProducts,
      applications
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

// Notes:
// 1. For ratings in related/recommended: Compute on-the-fly or store in Product.
// 2. Images: URLs can be from cloud storage (e.g., AWS S3).
// 3. For review breakdown (e.g., 70% 5-star): Query Reviews with $group in Mongo aggregate.
// 4. Update the frontend to fetch via API (e.g., useState with useEffect to call /api/products/:id).
// 5. Add validation, error handling, and authentication (e.g., for reviews) as needed.
// 6. If using SQL (e.g., PostgreSQL), convert to Sequelize models similarly.